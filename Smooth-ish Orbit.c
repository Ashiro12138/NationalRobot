#pragma config(Sensor, S1,     DIMC,           sensorEV3_GenericI2C)
#pragma config(Sensor, S2,     ,               sensorEV3_GenericI2C)
#pragma config(Sensor, S3,     inf1d,          sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     inf2d,          sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          FR,            tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          BR,            tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorC,          BL,            tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          FL,            tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-ev3smux.h"
#include "hitechnic-irseeker-v2.h"


int dir;

float mux[3];

tMSEV3 muxedSensor[3];
tEV3SensorTypeMode typeMode[3] = {colorReflectedLight, colorReflectedLight, colorReflectedLight};
/*
int goalcomp; //Goal Direction
int Sorbit = 50; //Orbit Speed
int Saim = 50; //Aiming speed
int range = 6; //Radius of Accuracy (The lower the better accuarcy)
int Sshooting = 100; //Shooting Speed
int comp,inf1,inf1s,inf2,inf2s,maxcomp,mincomp,complogic;
bool Rcomp;


//Movement Functions
void Mstop()   {motor[FL] = 0;  motor[FR] = 0;  motor[BR] = 0;  motor[BL] = 0;}
void Mforward(){motor[FL] = Sshooting; motor[FR] = Sshooting; motor[BR] = -Sshooting;motor[BL] = -Sshooting;}
void Mright()  {motor[FL] = -Sorbit;motor[FR] = Sorbit; motor[BR] = Sorbit; motor[BL] = -Sorbit;}
void Mmright() {motor[FL] = -Saim;motor[FR] = Saim; motor[BR] = Saim; motor[BL] = -Saim;}
void Mleft()   {motor[FL] = Sorbit; motor[FR] = -Sorbit;motor[BR] = -Sorbit;motor[BL] = Sorbit;}
void Mmleft()  {motor[FL] = Saim; motor[FR] = -Saim;motor[BR] = -Saim;motor[BL] = Saim;}
void Mback()   {motor[FL] = -Sorbit;motor[FR] = -Sorbit;motor[BR] = Sorbit; motor[BL] = Sorbit;}
void Tleft()   {motor[FL] = Saim; motor[FR] = Saim; motor[BR] = Saim; motor[BL] = Saim;}
void Tright()  {motor[FL] = -Saim;motor[FR] = -Saim;motor[BR] = -Saim;motor[BL] = -Saim;}
*/

int target = 2*SensorValue[S1];

int compassRelative(int current)
{
	current = current*2;
	int diff = current - target;

	if (diff > 180)
	{
		diff -= 360;
	}
	else if (diff < -180)
	{
		diff += 360;
	}
	return diff;
}

int speeds[21][4]= {{0,0,0,0},
{-100, -100, 100, 100},
{-51, -100, 51, 100},
{-16, -100, 16, 100},
{16, -100, -16, 100},
{51, -100, -51, 100},
{100, -100, -100, 100},
{100, -51, -100, 51},
{100, -16, -100, 16},
{100, 16, -	00, -16},
{100, 51, -100, -51},
{100, 100, -100, -100},
{51, 100, -51, -100},
{16, 100, -16, -100},
{-16, 100, 165, -100},
{-51, 100, 51, -100},
{-100, 100, 100, -100},
{-100, 51, 100, -51},
{-100, 16, 100, -16},
{-100, -16, 100.0, 16},
{-100, -51, 100.0, 51}};

void motorMove(int dir, int speedMulti)
{
	int compRel = compassRelative(SensorValue[S1])*0.4;
	motor[FR] = speeds[dir][0]*speedMulti + compRel;
	motor[BR] = speeds[dir][1]*speedMulti + compRel;
	motor[BL] = speeds[dir][2]*speedMulti + compRel;
	motor[FL] = speeds[dir][3]*speedMulti + compRel;
}
/*
//Movement Functions
void Mstop()   {motor[FL] = 0  + compassRelative(SensorValue[S1])*0.4;  motor[FR] = 0  + compassRelative(SensorValue[S1])*0.4;  motor[BR] = 0  + compassRelative(SensorValue[S1])*0.4;  motor[BL] = 0 + compassRelative(SensorValue[S1])*0.4;}
void Mforward(){motor[FL] = Sshooting + compassRelative(SensorValue[S1])*0.4; motor[FR] = Sshooting + compassRelative(SensorValue[S1])*0.4; motor[BR] = -Sshooting+ compassRelative(SensorValue[S1])*0.4;motor[BL] = -Sshooting + compassRelative(SensorValue[S1])*0.4;}
void Mright()  {motor[FL] = -Sorbit + compassRelative(SensorValue[S1])*0.4;motor[FR] = Sorbit+ compassRelative(SensorValue[S1])*0.4; motor[BR] = Sorbit+ compassRelative(SensorValue[S1])*0.4; motor[BL] = -Sorbit+ compassRelative(SensorValue[S1])*0.4;}
void Mmright() {motor[FL] = -Saim+ compassRelative(SensorValue[S1])*0.4;motor[FR] = Saim+ compassRelative(SensorValue[S1])*0.4; motor[BR] = Saim+ compassRelative(SensorValue[S1])*0.4; motor[BL] = -Saim+ compassRelative(SensorValue[S1])*0.4;}
void Mleft()   {motor[FL] = Sorbit+ compassRelative(SensorValue[S1])*0.4; motor[FR] = -Sorbit+ compassRelative(SensorValue[S1])*0.4;motor[BR] = -Sorbit+ compassRelative(SensorValue[S1])*0.4;motor[BL] = Sorbit+ compassRelative(SensorValue[S1])*0.4;}
void Mmleft()  {motor[FL] = Saim+ compassRelative(SensorValue[S1])*0.4; motor[FR] = -Saim+ compassRelative(SensorValue[S1])*0.4;motor[BR] = -Saim+ compassRelative(SensorValue[S1])*0.4;motor[BL] = Saim+ compassRelative(SensorValue[S1])*0.4;}
void Mback()   {motor[FL] = -Sorbit+ compassRelative(SensorValue[S1])*0.4;motor[FR] = -Sorbit+ compassRelative(SensorValue[S1])*0.4;motor[BR] = Sorbit+ compassRelative(SensorValue[S1])*0.4; motor[BL] = Sorbit+ compassRelative(SensorValue[S1])*0.4;}
void Tleft()   {motor[FL] = Saim+ compassRelative(SensorValue[S1])*0.4; motor[FR] = Saim+ compassRelative(SensorValue[S1])*0.4; motor[BR] = Saim+ compassRelative(SensorValue[S1])*0.4; motor[BL] = Saim+ compassRelative(SensorValue[S1])*0.4;}
void Tright()  {motor[FL] = -Saim+ compassRelative(SensorValue[S1])*0.4;motor[FR] = -Saim+ compassRelative(SensorValue[S1])*0.4;motor[BR] = -Saim+ compassRelative(SensorValue[S1])*0.4;motor[BL] = -Saim+ compassRelative(SensorValue[S1])*0.4;}
*/


task main()
{ //Initialize
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2;

	initSensor(&irSeeker1, inf1d);
	initSensor(&irSeeker2, inf2d);
	while(true)
	{
		//Gaining data from sensors
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);
		int inf1 = irSeeker1.acDirection;
		int inf2 = irSeeker2.acDirection;

		int irDir;

		if (inf1 != 0) irDir = inf1;
		else if (inf2 != 0) irDir = inf2;
		else irDir = 0;

		motorMove(irDir, 0);
	}
}
